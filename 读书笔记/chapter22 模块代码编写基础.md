## 模块的创建
* 模块怎么命名都可以,但是如果打算将其导入,模块文件名就一个以.py结尾.对于会执行单不会被导入的顶层文件而言,``.py``从技术上来讲是可有可无的,但是每次都加上去,可以确保文件类型更醒目,并允许以后可以被导入
* 模块名在Python程序中会变成变量名(没有``.py``).因此,应该遵循普通变量名的命名规则
* 当一个模块被导入时,Python会把内部模块名映射到外部文件名,也就是通过把模块搜索路径中的目录路径加在前边,而``.py``或其他后缀名添加在后边.例如:名为M的模块最后会映射到某个包含模块查询代码的外部文件:``<directory\M.<extension>``

## 模块的使用
* import会读取整个模块,所以必须进行定义后才能读取它的变量名;from将获取(或者说是复制)模块特定的变量名
* import语句:``import module1``中,变量名module1有两个不同目的:识别要被载入的外部文件,**同时会生成脚本的变量,在文件加载后,用来引用模块对象**
* from语句:因为from会把变量名复制到另外一个作用域,所以它就可以让我们直接在脚本中使用复制后的变量名,而不需要模块
* from语句其实只是稍微扩展了import语句而已.它照常导入了模块文件,但是多了一个步骤,将文件中的一个或多个变量名从文件中复制了出来
* 莫魁岸会在第一个import或from时载入并执行,并且只在第一次如此.在默认情况下,Python只对每个文件的每个进程做一次操作.之后的导入操作都只会取出已加载的模块对象
* 像def一样,import和from是可执行语句,而不是编译期间的声明,而且他们可以嵌套在if、def中.知道执行程序时,Python执行到这些语句才会进行解析.此外,像def一样,import和from都是隐性的赋值语句(import把整个模块对象赋值给一个变量名,from将一个或多个变量名复制给另外一个模块中同名的对象)
* 以from复制的变量名会变成对共享对象的引用.就像函数的参数,对已取出的变量名重新赋值,对于其复制之处的模块并没有影响,但是修改一个已取出的可变对象,则会影响导入的模块内的对象
* 以from复制而来的变量名和其来源的文件并没有联系,为了实际修改另外一个文件中的全局变量名,必须使用import
* import将整个模块导入到内存.from的第一步骤也是普通的导入操作,因此,from总是会把整个模块导入到内存中.无论从整个文件中复制出多少变量名,只记载模块文件的一部分是不可能的,但是因为模块在Python中是字节码而不是机机器码,通常可以忽略效率的问题.
* from语句会让变量位置更隐秘和模糊.from有破坏命名空间的潜质
* 简单模块一般倾向于使用import而不是from.多数的from语句是用于明确列举出想要的变量

##模块的命名空间
* 模块最好理解为变量名的封装,也就是定义想让系统其它部分看见变量名的常说.从技术上讲,模块通常相应于文件,而Python会建立模块对象,以包含模块文件内所复制的所有变量名.**简而言之,模块就是命名空间(变量名建立所在的场所),而存在于模块之内的变量名就是模块对象的属性.**

###文件生成命名空间
* 文件生成命名空间:在模块文件顶层(也就是不在函数或类的主体内)每一个赋值了的变量名都会变成该模块的属性
* **模块语句在首次导入时执行**:系统中,模块的在第一次导入无论在什么地方,Python都会建立空的模块对象,并逐一执行该模块文件内的语句,依照文件从头到尾的顺序
* **顶层的复制语句会创建模块属性**:在导入时,文件顶层(不在def或class之内)赋值变量的语句(例如,=和def),会建立模块对象的属性,复制的变量名会存储在模块的命名空间内
* **模块的命名空间能通过``__dict__``或``dir(M)``获取**.由导入而建立的模块的命名空间是字典;可通过模块对象相关联的``__dict__``属性来读取,而且能通过``dir``函数查看.``dir``函数大致与对象``__dict``属性的键排序后的列表想等
* **模块是一个独立的作用域(本地变量就是全局变量)**.模块的顶层变量名遵循和函数内变量名相同的引用/赋值规则,但是,本地作用域和全局作用域相同(更正式的说法是,遵循我们于17章提及的LEGB范围的规则,但是没有L和E搜索层次).但是,在模块中,模块的范围会在模块加载后变成模块对象的属性辞典.和函数不同的是(本地变量名只在函数执行时才存在),导入后,模块的作用域就变成了模块对象的属性的命名空间.

###属性的点号运算
* **属性的点好运算和作用域法则没有关系.**当使用点号运算来读取变量名时,就把明确的对象提供给Python,来从其中取出赋值的变量名.LEGB规则只适用于无点号运算的纯变量名.
* **简单变量**:X是指在当前作用域内搜索变量名X(遵循LEGB规则)
* **点号运算**:X.Y是指在当前范围内搜索X,然后搜索对象X之中的属性Y(而非在作用域中)
* **多重点号运算**:X.Y.Z指的是寻找对象X之中的变量名Y,然后再找对象X.Y之中的Z
* **点通用性**点号运算可用于任何具有属性的对象:模块、类、C扩展类型等

###导入和作用域
* 不能自动看见另外一个文件内的变量名,变量的含义一定是由源代码中的复制语句的位置绝对的,而属性总是伴随着对对象的请求

``` python
moda.py

X = 88
def f():
	global X
	X = 99
```
``` python
modb.py

import moda
moda.f()
print(X, moda.X) # 11 99
```
* 上述代码执行的时候修改的moda中的X,而不是modb中的X.换句话说,导入操作不会赋予被导入文件中的代码对上层代码的可见度:被盗导入文件无法看见的文件内的变量名.更准确的说法是:
	* 函数绝对无法看见其他函数内的变量名,除非它们从屋里上处于这个函数内
	* 模块程序代码绝对无法看见其他模块内的变量名,除非明确进行导入
* **在Python中,一段程序的作用域完全由程序所处的文件中实际文件为准绝对.作用域绝对不后悔被函数调用或模块导入影响**

###命名空间的嵌套
* 虽然导入不会使命名空间发生向上的嵌套,但确实会发生向下的嵌套.利用属性的点好运算路径,有可能深入到任意嵌套的模块中并读取其属性
```python
mod1.py
X = 1
mod2.py
imoprt
X = 2
mod3.py
import mod2
X = 3
print mod2.mod1.X
```
* 可以点号取值``mod2.mod1.X``.但是无法``import mod2.mod1``这个语法牵涉所谓的包(目录)导入.包导入也会形成模块命名空间的嵌套

##重载模块
TODO