除了模块名,导入也可以制定目录路径.Python代码的目录称为包,因此这类导入就称为包导入.**事实上,包导入时把计算机的目录变成另外一个Python命名空间,而属性则对应于目录中所包含的子目录和模块文件**

## 包导入基础
* ``import dir1.dir2.mod`` = ``dir0\dir1\dir2\mod.py``
* 一般地,包导入路径最左边的部分仍然是相对于我们在第21章所介绍的sys.path模块搜索路径的一个目录

### 包和搜索路径设置
* import语句中的目录路径只能是以点号间隔的变量.你不能在``import``语句中使用任何特点的路径语法.你所需要做的是,在模块搜索路径设置中使用平台特定的语法,来定义容器目录
* 实际上,模块搜索路径上搜索项目提供了平台指定的目录路径前缀,之后再在import的那些路径左边添加这些路径.import语句以与平台不想关的方式,提供了目录路径写法

### __init__.py文件
* 如果选择使用包导入,就必须多遵循一条约束:包导入语句的路径中的每个目录内都必须有``__init__.py``文件,否则导入包会失败.容器目录不需要这类文件,因为其本身没列在import语句中
> 像这样的目录结构 
> dir0\dir1\dir2\mod.py
> 以及这种形式的import语句:
> import dir1.dir2.mod
> 必须遵循下列规则:
> dir1和dir2中必须有一个__init__.py文件
> dir0是容器,不需要__init__.py文件,如果有的话,这个文件也会被忽略
> dir0必须列在模块搜索路径上
>
>目录结构应该这样:
> ```python
> dir\
>  dir1\
>     __init__.py
>     dir2\
>         __init__.py
>         mod.py
> ```

* ``__init__.py``可以包含Python代码,就像普通模块文件.这类文件从某种程度上讲就像Python的一种声明,也可以完全为空.作为声明,这些文件可以防止有相同名称的目录不小心隐藏在搜索路径中,而之后才出现真正需要的模块.
* 更通常的情况下,``__init__.py``文件扮演了包初始化的钩子、替目录产生模块命名空间以及使用目录导入时实现``from ... import *``行为的角色
	* **包的初始化**:Python首次导入某个目录时,会自动执行该目录下__init__.py文件中的所有程序代码.因此这类文件自然是放置包内文件所需要初始化的代码的场所.例如,包可以使用其初始化文件,创建数据文件,连接数据库
	* **模块命名空间的初始化**:在包导入的模型中,脚本内的目录路径,在导入后会变成真实的嵌套对象路径.例如,上一个例子中,导入后,表达式``dir1.dir2``会运行,并返回一个模块对象,而此对象的命名空间包含了dir2的__init.py所复制的所有变量名.这类文件为目录(没有实际相配的模块文件)所创建的模块对象提供了命名空间
	* ** ``from *``语句的行为**:作为一个高级功能,你可以再``__init__.py``文件内使用``__all__``列表来定义目录以``form *``导入时,需要导出什么.在``__init__.py``文件中,``__all__``列表是指当包(目录)名称使用``from *``的时候,应该导入的子模块的名称清单.如果没有指定``__all__``,``from *``语句不会自动加载嵌套于该目录内的子模块,取而代之的是,只加载该目录的``__init__.py``内赋值语句定义的变量名,包括该文件中程序代码明确导入的任何子模块


##包导入实例
目录结构应该这样:
```python
 dir\
  dir1\
     __init__.py
     dir2\
         __init__.py
         mod.py
```
运行结果
```python
In[2]:import dir1.dir2.mod
dir1 init
dir2 init
in mod.py
In[3]:dir1
Out[3]: <module 'dir1' from 'F:\Algorithm-primary-class-python\dir1\__init__.py'>
In[4]:dir1.dir2
Out[4]: <module 'dir1.dir2' from 'F:\Algorithm-primary-class-python\dir1\dir2\__init__.py'>
In[5]:dir1.dir2.mod
Out[5]: <module 'dir1.dir2.mod' from 'F:\Algorithm-primary-class-python\dir1\dir2\mod.py'>
In[6]:dir1.x
Out[6]: 1
In[7]:dir1.dir2.y
Out[7]: 2
In[8]:dir1.dir2.mod.z
Out[8]: 3
```
* 导入后,import语句内的路径会变成脚本的嵌套对象路径.在这里,mod是对象,嵌套在对象dir2中,而dir2又嵌套在对象dir1中
* 实际上,**路径中的每个目录名称都会变成赋值了模块对象的变量**,而模块对象的命名空间则是由该目录的

##包相对导入
* 在Python3.0和Python2.6中,我们可以使用from语句前面的点号来表示,导入一个相对于外围的包--这样的导入将至少在包的内部搜索,并且不会搜索位于导入搜索路径(sys.path)上某处的同名模块.直接效果是包模块覆盖了外部模块
* 在Python2.6中,包的代码中的常规导入(没有前面的点好),目前默认为一种先相对再绝对的搜索路径顺序,也就是说,它们首先搜索包自己的路径.然而,在Python3.0,在一个包中导入默认是绝对的-在缺少任何特殊的点语法的时候,导入忽略包含包自身并在sys.path搜索路径上的某处寻找