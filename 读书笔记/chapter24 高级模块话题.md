## 在模块中国隐藏数据
* Python模块会导出其文件顶层所复制的所有变量名.没有对某一个变量名进行声明,使其在模块内可见或不可见这种概念.实际上,如果客户想的话,是没有防止客户端修改模块内变量名的办法
* Python中模块内的数据隐藏式一种惯例,不是语法约束.Pythone的封装更像打包,而不是约束

### 最小化``from *``的破坏:``_X``和``__all__``
* 把下划线放在变量名前面,可以防止客户端使``from *``语句导入模块名时,把其中的变量名复制出去.下划线不是"私有"声明:你还是可以使用其他导入形式看见并修改这类变量名.例如,使用import
* 此外,也可以在模块顶层把变量名的字符串列表复制给变量``__all__``指出要复制的变量名.使用此功能时,``from *``语句只会把列在``__all__``列表的这些变量名复制出来.
* Python会先寻找模块内的``__all__``列表;如果没有定义的话,``from *``就会复制出开头没有单下划线的所有变量名

## 启用以后的语言特性
* ``from __future__ import featurename``这个语句一般员工出现在模块文件的顶端

## 混合用法模式:``__name__``和``__main__``
* 文件以顶层程序文件执行,在启动时,``__name__``就会设置为字符串``__main__``
* 如果文件被导入,``__name__``就会设置为客户端所了解的模块名
* 模块可以坚持自己的``__name__``,来确定它是在导入还是在执行
* ``__name__``测试最常用的是自我测试代码
* 在Python中,sys.argv列表包含了命令行参数,它是反应在命令行上录入的单词的一个字符串列表,其中第一项总是将要运行的脚本名称(TODO)

## 修改模块搜索路径
* 修改sysy.path的内在列表
* 注意,所有导入和文件都共享一个sys.path列表

## import和from的as扩展
TODO

## 模块时时对象:元程序
* 模块通过内在属性显示了大多数有趣的特性,因此,可很容易地编写程序来管理其他程序,我们通常称这类管理程序为元程序,因为它们是在其他系统之上工作.这也成为内省,因为程序能看见和处理对象内部,内省是高级功能,但是,它可以用作创建程序的工具.
TODO

## 用名称字符串导入模块
* ``exec("import string")``编译一个代码字符
* ``__import__("string")``运行模块对象
* ``exec``每次运行它必须编译import语句,``__import__``更快

## 过渡性模块重载
TODO

## 模块设计理念
* **总是在Python的模块内编写代码**:没有办法写出不在某个模块之内的查询代码.事实上,在交互模式提示符下输入的查询代码,其实是存在于内置模块``__main__``只内
* **模块耦合要降到最低:全局变量**:模块应该尽可能和其他模块的全局变量无关,除了从模块导入函数和类
* **最大化模块的黏合性:统一目标**:模块的所有元素都享有共同的目的
* **模块应该少去修改其他模块的变量**:使用另外一个模块定义的全局变量,这是完全可以的(笔记这就是科幻导入服务的方式),但是修改另一个模块的全局变量,通常是出现设计问题的征兆.也有例外,但是应该试着通过函数参数返回值这类的机制去传递结果,而不是进行跨模块的修改.否则,全局变量的值会变成依赖于其他文件内的任意远程赋值语句的顺序,而模块会变得难以理解和再利用

## 模块陷阱
### 顶层代码语句次序的重要性
当模块首次导入或重载时,Python会从头到尾执行语句,这里有些向前应用相关的含义,值得强调:
* 在导入时,模块文件顶层的程序代码(不在函数内)一旦Python运行到时就会立刻执行(类的类变量也会运行到),因此该语句是无法引用文件后面位置赋值的变量名
* 位于函数主体内的代码知道函数被调用后才会运行.业务函数内的变量名在函数实际执行前都不会解析,通常可以引用文件内任意地方的变量
* 在顶层程序混用def不仅难读,也造成了对语句顺序的依赖性.作为一条原则,如果需要把立刻执行的代码和def一起混用,就要把def放在文件前面,把顶层代码放在后面.这样的话,你的函数在使用的代码运行的时候,可以保证它们都已定义并赋值过

### from复制变量名,而不是连接
* ``from``语句其实是在导入者的作用域内对变量名的赋值语句,也就是变量名拷贝运算,而不是变量名的别名机制

### ``from *``会让变量语义模糊
* 试着在from语句中明确列出想要的属性
 
### reload不会影响from导入
* from在执行时会复制(赋值)变量名,所以不会连接到变量名的模块.通过fromd导入的变量名就简单变成了对象的引用,当from运行时这个对象恰巧在被导入者内由相同的变量名引用
* from语句复制的是变量名,而不是模块.要在导入者使用模块,要import
* TODO

### 递归形式的from导入无法工作
* 因为导入会从头到尾执行一个文件的语句,使用相互导入的模块的时候,需要相当小心.因为一个模块内的语句在其导入另外一个模块时不会全都执行,有些变量名可能还不存在
* 例如,考虑下列模块recur1和recur2.recur1给变量X赋了值,然后在赋值变量名Y之前引入了recur2.这时,recur可以用import把recur1整个取出(recur1已经存在于Python的内部的模块表),但是,如果使用from,就只能看见变量名X.变量名Y是在导入recur1后赋值,现在不存在,所以会产生错误.
> \# recur1.py
> X = 1
> import recur2
> Y = 2
> 
> \# recur2.py
> from recur1 import X
> from recur1 import Y
> 
> \>>>>import recur1
> 	cannot import name Y
* 当recur1的语句被recur2递归导入时,Python会避免重新执行(否则会让脚本变成死循环),但是,被recur2导入时,recur1的命名空间还不完整
* 解决办法就是,不要在递归导入中使用from.如果这么做,Python不会卡在死循环中,但是,程序有会依赖于模块中语句的顺序
* 有两种方式避开这个陷阱:
	1. 小心设计,通常可以避免这种导入循环:最大化模块聚合性,同时最小化模块间耦合性
	2. 如果无法完全断开循环,就要使用import和点号运算(而不是from),将模块变量名的读取放在后边,要么就是函数中,或者在文件末尾附近去执行from(而不是在模块顶层),以延迟其执行
